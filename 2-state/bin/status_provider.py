#!/usr/bin/env python3
"""
ConfD ステータスプロバイダーデーモン

このスクリプトはConfDのデータプロバイダーとして動作し、
'show server-status' コマンドで表示されるサーバーステータス情報を提供します。

提供する情報:
- uptime: サーバーの稼働状態メッセージ
- last-checked-at: 最後にチェックした時刻（HH:MM:SS形式）

YANGモデル:
- ファイル: yang/example.yang
- 名前空間: bin/example_ns.py
- コールポイント名: server_status_cp

【使用方法】
    --start      : デーモンとして起動
    --stop       : デーモンを停止
    --status     : デーモンの状態を確認
    --foreground : フォアグラウンドで実行（テスト用）
"""

import argparse
import atexit
import os
import select
import signal
import socket
import sys
import time

from datetime import datetime
from pathlib import Path
from typing import Optional

try:
    import _confd  # type: ignore
    import _confd.dp as dp  # type: ignore
except ImportError as e:
    print(f"Error: Could not import required ConfD modules: {e}")
    print("Make sure ConfD is installed and PYTHONPATH is set correctly.")
    sys.exit(1)

try:
    import example_ns as ns
except ImportError as e:
    print(f"Error: Could not import example_ns module: {e}")
    print("Make sure example_ns.py is generated by confdc from the YANG model.")
    sys.exit(1)

# =============================================================================
# 定数定義
# =============================================================================

# スクリプトのファイル名の拡張子を取り除いた名前
SCRIPT_BASE = Path(__file__).stem

# スクリプトのディレクトリを基準にパスを設定
SCRIPT_DIR = Path(__file__).resolve().parent.parent

TMP_DIR = SCRIPT_DIR / 'tmp'
LOG_DIR = SCRIPT_DIR / 'log'

# PIDファイル
PID_FILE = TMP_DIR / f'{SCRIPT_BASE}.pid'

# ログファイル
LOG_FILE = LOG_DIR / f'{SCRIPT_BASE}.log'

# ConfD接続設定
CONFD_HOST = "127.0.0.1"
CONFD_PORT = 4565

# コールポイント名（YANGファイルで定義したもの）
CALLPOINT_NAME = "server_status_cp"

# デーモン名
DAEMON_NAME = "status_provider_daemon"

# YANGノードのハッシュ値を取得
# ConfDは内部的にハッシュ値で識別するため、confdcで生成したpythonモジュールからハッシュ値を取得する
UPTIME_HASH = str(ns.ns.ex_uptime)
LAST_CHECKED_HASH = str(ns.ns.ex_last_checked_at)

# プロセス起動時刻（uptimeの表示に使用）
START_TIME = datetime.now()

# Workerソケットのグローバル参照
# トランザクションコールバックで使用するため、グローバル変数として保持
wrksock_global: Optional[socket.socket] = None

# =============================================================================
# コールバッククラス
# =============================================================================
# 【2つのクラスの役割分担】
#
# このスクリプトでは、ConfDとのやり取りのために2つのクラスを使用しています：
#
# 1. TransCallbacks (トランザクション管理)
#    - 役割: データ取得の「準備」と「後始末」を担当
#    - いつ呼ばれる: ConfDがデータを読み取る「前」と「後」
#    - 何をする: ソケット接続の確立とクリーンアップ
#
# 2. DataCallbacks (実データ提供)
#    - 役割: 実際のデータを返す
#    - いつ呼ばれる: ConfDが特定のデータ（uptimeやlast-checked-at）を要求したとき
#    - 何をする: 要求されたデータを計算して返却
#
# 【処理フローの例】
# ユーザーがConfD CLIで 'show server-status' を実行すると：
#   1. TransCallbacks.cb_init()       ← トランザクション開始（準備）
#   2. DataCallbacks.cb_get_elem()    ← uptimeを要求 → データを返す
#   3. DataCallbacks.cb_get_elem()    ← last-checked-atを要求 → データを返す
#   4. TransCallbacks.cb_finish()     ← トランザクション終了（後始末）
#
# 【なぜ2つに分かれているか】
# - データ取得には「準備→取得→終了」というライフサイクルがある
# - TransCallbacksは共通の準備・後始末を一箇所で管理
# - DataCallbacksは個別のデータ要求に対応（拡張が容易）
# =============================================================================

class TransCallbacks:
    """
    【クラス1】トランザクション管理用コールバック

    【役割】
    ConfDがデータを読み取る際の「セッション管理」を担当します。
    データベースでいうところの BEGIN TRANSACTION と COMMIT に相当します。

    【主な責務】
    - cb_init: データ取得セッションの開始時にソケットをセットアップ
    - cb_finish: データ取得セッションの終了時のクリーンアップ

    【実装パターン】
    このクラスは通常、ほぼ定型コードです。カスタマイズが必要なのは
    DataCallbacksクラスの方で、このクラスは標準的な実装で問題ありません。
    """

    def cb_init(self, tctx) -> int:
        """
        トランザクション初期化コールバック

        【呼ばれるタイミング】
        ConfDがデータの読み取りを開始する「直前」に呼ばれます。
        例: ユーザーが 'show server-status' を実行した瞬間

        【処理内容】
        Workerソケット（wrksock_global）をトランザクションコンテキスト（tctx）
        に紐付けます。これにより、ConfDはこのソケットを通じて後続のデータ要求を
        送信できるようになります。

        【アナロジー】
        電話をかけて回線を確立するようなもの。回線が確立されて初めて
        会話（データのやり取り）ができるようになります。

        Args:
            tctx: トランザクションコンテキスト（ConfDが管理するセッション情報）

        Returns:
            _confd.OK: 成功（データ取得処理を続行）
            _confd.ERR: エラー（データ取得を中止）
        """
        try:
            # Workerソケットをトランザクションに紐付ける
            # これにより、ConfDはこのソケットを通じてデータ要求を送信できる
            dp.trans_set_fd(tctx, wrksock_global)
            print("DEBUG: Transaction initialized successfully")
            return _confd.OK
        except Exception as e:
            print(f"ERROR: Transaction initialization failed: {e}")
            return _confd.ERR

    def cb_finish(self, tctx) -> int:
        """
        トランザクション終了コールバック

        【呼ばれるタイミング】
        ConfDがすべてのデータ取得を完了した「後」に呼ばれます。
        例: 'show server-status' のすべてのデータを取得し終わった後

        【処理内容】
        現在の実装では特に何もしていません（単に_confd.OKを返すだけ）。
        必要に応じて、ここでリソースのクリーンアップやログ出力を行えます。

        【アナロジー】
        電話を切る動作に相当します。会話が終わったら回線を切断します。

        Args:
            tctx: トランザクションコンテキスト

        Returns:
            常に _confd.OK（正常終了）
        """
        return _confd.OK


class DataCallbacks:
    """
    【クラス2】データ取得用コールバック

    【役割】
    ConfDが特定のデータを要求したときに、実際のデータを生成して返します。
    このスクリプトの「本体」とも言える部分です。

    【主な責務】
    - cb_get_elem: 要求されたYANGノード（uptime, last-checked-atなど）の
                   値を計算して返す

    【カスタマイズポイント】
    新しいステータス情報を追加する場合は、主にこのクラスを拡張します：
    1. cb_get_elem()内に新しいif文を追加
    2. データ生成用のヘルパーメソッド（_get_xxx）を追加

    【設計のポイント】
    - 各データ生成ロジックは_get_xxx()メソッドに分離（保守性向上）
    - ハッシュ値でYANGノードを識別（パス文字列より確実）
    """

    def cb_get_elem(self, tctx, kp) -> int:
        """
        要素取得コールバック

        【呼ばれるタイミング】
        ConfDが特定のYANGノード（例: uptime, last-checked-at）の値を
        要求したときに呼ばれます。1つのデータ要求につき1回呼ばれます。

        【処理フロー】
        1. キーパス（kp）から、どのYANGノードが要求されたか判定
        2. ハッシュ値を使って、uptimeかlast-checked-atかを識別
        3. 該当するヘルパーメソッドを呼んでデータを生成
        4. dp.data_reply_value()でConfDにデータを返却

        【ハッシュ値の使用理由】
        パス文字列（例: "/server-status/uptime"）で判定することもできますが、
        ハッシュ値を使う方がより確実です。YANGモデルが変更されてもハッシュ値は
        自動的に更新されるため、保守性が高くなります。

        【拡張方法】
        新しいステータス情報を追加する場合：
        1. YANGファイルに新しいleafを追加
        2. confdc --emit-pythonでexample_ns.pyを再生成
        3. このメソッドに新しいelif文を追加

        例:
        ```python
        elif NEW_ITEM_HASH in path:
            value = self._get_new_item()
            val = _confd.Value(value, _confd.C_STR)
            dp.data_reply_value(tctx, val)
        ```

        Args:
            tctx: トランザクションコンテキスト（データ返却に使用）
            kp: キーパス（要求されたYANGノードのパス情報）

        Returns:
            _confd.OK: データ返却成功
            _confd.ERR: エラー発生
            2 (NOT_FOUND): 要求されたパスが存在しない
        """
        try:
            path = str(kp)
            print(f"DEBUG: Data request for path: {path}")

            # ハッシュ値を使ってどのノードが要求されたか判定
            # UPTIME_HASH や LAST_CHECKED_HASH は、ファイル先頭で定義されています

            if UPTIME_HASH in path:
                # uptime ノード: サーバーの稼働状態を返す
                # 処理フロー: データ生成 → ConfD形式に変換 → 返却
                uptime_msg = self._get_uptime_message()
                val = _confd.Value(uptime_msg, _confd.C_STR)
                dp.data_reply_value(tctx, val)
                print(f"DEBUG: Returned uptime: {uptime_msg}")

            elif LAST_CHECKED_HASH in path:
                # last-checked-at ノード: 現在時刻を返す
                # 処理フロー: データ生成 → ConfD形式に変換 → 返却
                current_time = self._get_current_time()
                val = _confd.Value(current_time, _confd.C_STR)
                dp.data_reply_value(tctx, val)
                print(f"DEBUG: Returned last-checked-at: {current_time}")

            else:
                # 未知のパス（YANGモデルに存在しないノード）
                print(f"WARN: Unknown path requested: {path}")
                # NOT_FOUND (2) を返す
                # 定数インポートのトラブルを避けるため数値を直接使用
                return 2

            return _confd.OK

        except Exception as e:
            print(f"ERROR: Failed to get element: {e}")
            return _confd.ERR

    @staticmethod
    def _get_uptime_message() -> str:
        """
        稼働状態メッセージを取得

        【処理内容】
        プロセス起動時刻（START_TIME）と現在時刻の差分から、
        このデーモンがどのくらい稼働しているかを計算します。

        【実装のポイント】
        - @staticmethodデコレータを使用（インスタンス変数を使わないため）
        - グローバル変数START_TIMEを参照
        - 時間と分で表示（秒は省略して読みやすく）

        【カスタマイズ例】
        より詳細な情報を追加する場合：
        ```python
        seconds = int(elapsed.total_seconds() % 60)
        return f"Uptime: {hours}h {minutes}m {seconds}s"
        ```

        Returns:
            稼働状態を示すメッセージ文字列（例: "Up and running! (Uptime: 2h 30m)"）
        """
        elapsed = datetime.now() - START_TIME
        hours = int(elapsed.total_seconds() // 3600)
        minutes = int((elapsed.total_seconds() % 3600) // 60)

        return f"Up and running! (Uptime: {hours}h {minutes}m)"

    @staticmethod
    def _get_current_time() -> str:
        """
        現在時刻を取得

        【処理内容】
        現在時刻をHH:MM:SS形式（24時間表記）で返します。

        【実装のポイント】
        - strftime()で簡潔にフォーマット
        - YANGモデルの型（yang:date-and-time）に合わせた形式

        【カスタマイズ例】
        日付も含める場合：
        ```python
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        ```

        Returns:
            HH:MM:SS形式の時刻文字列（例: "14:35:22"）
        """
        return datetime.now().strftime("%H:%M:%S")


# =============================================================================
# メイン処理
# =============================================================================

def run() -> None:
    """
    ステータスプロバイダーデーモンのメイン処理

    【全体フロー】
    1. 初期化: ConfDデーモンコンテキストとソケットを作成
    2. 接続: ConfDサーバーに接続
    3. 登録: TransCallbacksとDataCallbacksを登録
    4. 待機: メインループでConfDからの要求を待ち受け
    5. 終了: シグナル受信時にクリーンアップして終了

    【2つのソケットの役割】
    - ctlsock (制御用): デーモンの登録・制御に使用
    - wrksock_global (ワーカー用): 実際のデータ要求/応答に使用

    【コールバック登録の意味】
    - dp.register_trans_cb(): TransCallbacksを登録
      → ConfDがトランザクション開始/終了時にコールバックを呼び出せるようになる
    - dp.register_data_cb(): DataCallbacksをCALLPOINT_NAMEに関連付けて登録
      → YANGモデルのcallpoint "server_status_cp"とこのスクリプトが紐付けられる
    - dp.register_done(): 登録完了を通知
      → ConfDがこのデーモンを利用可能な状態にする
    """
    global wrksock_global

    # ConfDデーモンコンテキストを初期化
    print(f"INFO: Initializing daemon: {DAEMON_NAME}")
    dctx = dp.init_daemon(DAEMON_NAME)

    # ソケットを作成
    # 【ソケットの使い分け】
    # - ctlsock: デーモンとしての登録や管理に使用
    # - wrksock_global: データプロバイダーとしての実際の動作に使用
    ctlsock = socket.socket()  # 制御用ソケット
    wrksock_global = socket.socket()  # ワーカー用ソケット

    # 終了シグナルハンドラーの設定
    # 【実装のポイント】
    # 単純なbool変数ではなく辞書を使う理由：
    # signal_handlerは関数内関数なので、外側のローカル変数を変更するには
    # nonlocalキーワードが必要。辞書ならミュータブルなので直接変更可能。
    stop_flag = {'stop': False}

    def signal_handler(signum, frame):
        """シグナルハンドラー：Ctrl-CやSIGTERMで終了フラグをセット"""
        print("\nINFO: Shutdown signal received...")
        stop_flag['stop'] = True

    signal.signal(signal.SIGINT, signal_handler)   # Ctrl-C
    signal.signal(signal.SIGTERM, signal_handler)  # kill コマンド

    try:
        # ConfDに接続
        print(f"INFO: Connecting to ConfD at {CONFD_HOST}:{CONFD_PORT}")
        dp.connect(dctx, ctlsock, dp.CONTROL_SOCKET, CONFD_HOST, CONFD_PORT, None)
        dp.connect(dctx, wrksock_global, dp.WORKER_SOCKET, CONFD_HOST, CONFD_PORT, None)

        # コールバックを登録
        # 【登録の順序】
        # 1. まずトランザクションコールバック（TransCallbacks）を登録
        # 2. 次にデータコールバック（DataCallbacks）を登録
        # 3. 最後にregister_done()で登録完了を通知
        print("INFO: Registering callbacks")
        dp.register_trans_cb(dctx, TransCallbacks())
        dp.register_data_cb(dctx, CALLPOINT_NAME, DataCallbacks())
        dp.register_done(dctx)

        # メインループ: ソケットからのイベントを待機
        # 【メインループの仕組み】
        # select.select()を使って、ソケットに何かデータが来るまで待機します。
        # ConfDがデータを要求すると、該当するソケットが「読み取り可能」になり、
        # dp.fd_ready()を呼ぶことでConfDにコールバックを実行させます。
        #
        # 【処理の流れ】
        # 1. select()でソケットを監視（タイムアウト1秒）
        # 2. 読み取り可能なソケットがあれば、dp.fd_ready()を呼ぶ
        #    → ConfDが適切なコールバック（TransCallbacksやDataCallbacks）を呼び出す
        # 3. stop_flagがTrueになるまで繰り返す
        sockets = [ctlsock, wrksock_global]
        print("=" * 60)
        print("Status Provider is ready!")
        print(f"Try running: 'show server-status' in ConfD CLI")
        print("=" * 60)

        while not stop_flag['stop']:
            # select()でソケットの読み取り可能状態を監視（タイムアウト1秒）
            # タイムアウトを設定することで、stop_flagのチェックが定期的に行われます
            readable, _, _ = select.select(sockets, [], [], 1.0)

            # ソケットが読み取り可能になったことをConfDに通知します
            # これを受けたConfDはコールバック（TransCallbacks, DataCallbacks）を呼び出します
            for sock in readable:
                dp.fd_ready(dctx, sock)

    except Exception as e:
        if not stop_flag['stop']:
            print(f"ERROR: Unexpected error: {e}")
            raise
    finally:
        # クリーンアップ
        print("INFO: Closing sockets")
        ctlsock.close()
        if wrksock_global:
            wrksock_global.close()


# =============================================================================
# デーモン管理関数
# =============================================================================

def daemonize() -> None:
    """
    プロセスをデーモン化する

    二重forkを使用してデーモンプロセスを作成し、
    標準入出力をログファイルにリダイレクトします。
    """
    # ディレクトリを作成（存在しない場合）
    TMP_DIR.mkdir(exist_ok=True)
    LOG_DIR.mkdir(exist_ok=True)

    # 1回目のfork - 親プロセスから分離
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)  # 親プロセスを終了
    except OSError as e:
        sys.stderr.write(f"fork #1 failed: {e}\n")
        sys.exit(1)

    # セッションリーダーになる
    os.chdir('/')
    os.setsid()
    os.umask(0)

    # 2回目のfork - 制御端末から完全に切り離す
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError as e:
        sys.stderr.write(f"fork #2 failed: {e}\n")
        sys.exit(1)

    # 標準入出力をログファイルにリダイレクト
    sys.stdout.flush()
    sys.stderr.flush()

    with open(str(LOG_FILE), 'a') as log:
        os.dup2(log.fileno(), sys.stdout.fileno())
        os.dup2(log.fileno(), sys.stderr.fileno())

    # PIDファイルを作成
    with open(str(PID_FILE), 'w') as f:
        f.write(str(os.getpid()))

    # 終了時にPIDファイルを削除
    atexit.register(cleanup_pid_file)


def cleanup_pid_file() -> None:
    """PIDファイルを削除する"""
    if os.path.exists(PID_FILE):
        os.remove(PID_FILE)


def get_pid() -> Optional[int]:
    """
    PIDファイルからプロセスIDを取得する

    Returns:
        プロセスID、またはPIDファイルが存在しない場合はNone
    """
    try:
        with open(PID_FILE, 'r') as f:
            return int(f.read().strip())
    except (FileNotFoundError, ValueError):
        return None


def is_running(pid: Optional[int]) -> bool:
    """
    指定されたPIDのプロセスが実行中かチェックする

    Args:
        pid: チェックするプロセスID

    Returns:
        プロセスが実行中の場合True
    """
    if pid is None:
        return False
    try:
        os.kill(pid, 0)  # シグナル0は存在チェックのみ
        return True
    except OSError:
        return False


def start_daemon() -> None:
    """デーモンを起動する"""
    pid = get_pid()
    if is_running(pid):
        print(f"Status provider daemon is already running (PID: {pid})")
        sys.exit(1)

    # 古いPIDファイルを削除
    cleanup_pid_file()

    print("Starting status provider daemon...")
    print(f"Log file: {LOG_FILE}")

    daemonize()
    run()


def stop_daemon() -> None:
    """デーモンを停止する"""
    pid = get_pid()
    if not is_running(pid):
        print("Status provider daemon is not running")
        cleanup_pid_file()
        sys.exit(1)

    print(f"Stopping status provider daemon (PID: {pid})...")
    try:
        # TERMシグナルを送信してグレースフルシャットダウン
        os.kill(pid, signal.SIGTERM)

        # プロセスが終了するまで最大5秒待つ
        for _ in range(10):
            if not is_running(pid):
                break
            time.sleep(0.5)

        # まだ実行中の場合は強制終了
        if is_running(pid):
            print("Daemon did not stop gracefully, forcing...")
            os.kill(pid, signal.SIGKILL)

        print("Daemon stopped")
        cleanup_pid_file()
    except Exception as e:
        print(f"Error stopping daemon: {e}")
        sys.exit(1)


def status_daemon() -> None:
    """デーモンのステータスを表示する"""
    pid = get_pid()
    if is_running(pid):
        print(f"Status provider daemon is running (PID: {pid})")
        print(f"Log file: {LOG_FILE}")
    else:
        print("Status provider daemon is not running")
        cleanup_pid_file()


# =============================================================================
# メイン関数
# =============================================================================

def main() -> None:
    """エントリーポイント"""
    parser = argparse.ArgumentParser(
        description='ConfD status provider daemon',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --start        Start the daemon
  %(prog)s --stop         Stop the daemon
  %(prog)s --status       Check daemon status
  %(prog)s --foreground   Run in foreground (for testing)
        """
    )

    parser.add_argument('--start', action='store_true', help='Start the daemon')
    parser.add_argument('--stop', action='store_true', help='Stop the daemon')
    parser.add_argument('--status', action='store_true', help='Check daemon status')
    parser.add_argument('--foreground', action='store_true', help='Run in foreground (for testing)')

    args = parser.parse_args()

    # コマンドを実行
    if args.start:
        start_daemon()
    elif args.stop:
        stop_daemon()
    elif args.status:
        status_daemon()
    elif args.foreground:
        print("Running in foreground mode (Ctrl-C to stop)")
        try:
            run()
        except KeyboardInterrupt:
            print("\nStopped")
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()