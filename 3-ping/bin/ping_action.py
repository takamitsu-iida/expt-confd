#!/usr/bin/env python3
"""
ConfD pingアクションハンドラー

このスクリプトはConfDのアクションハンドラーとして動作し、
CLI上で 'ping <destination>' コマンドを実行可能にします。

提供する機能:
- ping実行: 指定されたホストまたはIPアドレスへpingを送信
- 結果表示: パケット送信/受信/損失、平均応答時間を表示
- 中断機能: Ctrl-Cで実行中のpingを中断可能

YANGモデル:
- ファイル: yang/example.yang
- 名前空間: bin/example_ns.py
- アクションポイント名: ping_action

【使用方法】
    --start      : デーモンとして起動
    --stop       : デーモンを停止
    --status     : デーモンの状態を確認
    --foreground : フォアグラウンドで実行（テスト用）

【CLI使用例】
    admin@confd> ping execute 8.8.8.8
    admin@confd> ping execute 8.8.8.8 count 5
    admin@confd> ping execute google.com

    実行中にCtrl-Cで中断可能

【制限事項】
    - ConfDのアクションフレームワークの制約により、pingの実行中は
      出力が表示されません。完了後に全結果が表示されます。
    - 進捗を確認したい場合は、別ターミナルで以下を実行してください:
      tail -f log/ping_action.log
"""

import argparse
import atexit
import os
import platform
import select
import signal
import socket
import subprocess
import sys
import threading
import time

from pathlib import Path
from typing import Any, Dict, List, Optional

try:
    import _confd  # type: ignore
    import _confd.dp as dp  # type: ignore
except ImportError as e:
    print(f"Error: Could not import required ConfD modules: {e}")
    print("Make sure ConfD is installed and PYTHONPATH is set correctly.")
    sys.exit(1)

try:
    import example_ns as ns
except ImportError as e:
    print(f"Error: Could not import example_ns module: {e}")
    print("Make sure example_ns.py is generated by confdc from the YANG model.")
    sys.exit(1)

# =============================================================================
# 定数定義
# =============================================================================

# スクリプトのファイル名の拡張子を取り除いた名前
SCRIPT_BASE = Path(__file__).stem

# スクリプトのディレクトリを基準にパスを設定
SCRIPT_DIR = Path(__file__).resolve().parent.parent

TMP_DIR = SCRIPT_DIR / 'tmp'
LOG_DIR = SCRIPT_DIR / 'log'

# ディレクトリが存在しない場合は作成
TMP_DIR.mkdir(parents=True, exist_ok=True)
LOG_DIR.mkdir(parents=True, exist_ok=True)

# PIDファイル
PID_FILE = TMP_DIR / f'{SCRIPT_BASE}.pid'

# ログファイル
LOG_FILE = LOG_DIR / f'{SCRIPT_BASE}.log'

# ConfD接続設定
CONFD_HOST = "127.0.0.1"
CONFD_PORT = 4565

# アクションポイント名（YANGファイルで定義したもの）
ACTION_POINT_NAME = "ping_action"

# デーモン名
DAEMON_NAME = "ping_action_daemon"

# ConfDワーカーソケットのグローバル参照
#
# ConfDのデータプロバイダ/アクションは、
#   - 制御用ソケット(ctrl_sock: デーモン登録や制御イベント用)
#   - ワーカーソケット(work_sock: 実際のリクエスト/レスポンス用)
# の2本を使います。
#
# この変数は後段の run_daemon() で生成したワーカーソケットを保持し、
# cb_init() 内の dp.action_set_fd(uinfo, work_sock_global) で
# 「このユーザのアクション応答は work_sock_global から返す」ことを
# ConfD に伝えるために使われます。
work_sock_global: Optional[socket.socket] = None

# 実行中のpingプロセスを管理する辞書（Ctrl-C中断用）
# キー: uinfo_key（UserInfoを文字列化したもの）
# 値: {'process': subprocess.Popen, 'aborted': bool}
active_pings: Dict = {}

# =============================================================================
# ログ関数
# =============================================================================

def log(message: str) -> None:
    """ログメッセージをファイルに書き込む"""
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
    with open(LOG_FILE, 'a') as f:
        f.write(f"[{timestamp}] {message}\n")


def build_ping_command(destination: str, count: int) -> List[str]:
    """OSごとに適切なpingコマンドを構築する"""
    system = platform.system()

    if system == "Windows":
        # Windows: ping -n <count> <destination>
        return ["ping", "-n", str(count), destination]

    # Linux / macOS: ping -c <count> <destination>
    return ["ping", "-c", str(count), destination]


def build_result_values(result_message: str, success: bool) -> List[Any]:
    """YANGの出力パラメータ(result, success)に対応するTagValueリストを生成"""
    return [
        _confd.TagValue(
            _confd.XmlTag(ns.ns.hash, ns.ns.ex_result),
            _confd.Value(result_message, _confd.C_BUF),
        ),
        _confd.TagValue(
            _confd.XmlTag(ns.ns.hash, ns.ns.ex_success),
            _confd.Value(success, _confd.C_BOOL),
        ),
    ]


def send_action_reply(uinfo: Any, result_message: str, success: bool) -> None:
    """アクションの遅延応答/即時応答を送信するヘルパー"""
    result_values = build_result_values(result_message, success)
    dp.action_reply_values(uinfo, result_values)

# =============================================================================
# Ping実行関数
# =============================================================================

def execute_ping(uinfo, destination: str, count: int = 4) -> None:
    """
    pingコマンドを実行し、完了時に結果を返す

    【実行モデル】
    この関数はcb_actionから別スレッドで呼び出されます。
    - cb_actionは_confd.DELAYED_RESPONSEを返してすぐに制御を戻す
    - この関数がバックグラウンドでpingを実行
    - 完了後、dp.action_reply_values()で結果を返す

    【Ctrl-C中断の仕組み】
    1. active_pings辞書にプロセスを登録
    2. Ctrl-Cが押されるとcb_abort()が呼ばれる
    3. cb_abort()がactive_pingsからプロセスを取得して終了
    4. process.terminate()によりpingプロセスが終了
    5. process.wait()が戻り、returncode < 0（シグナルで終了）を検知
    6. ConfDがクライアント接続を切断するため、応答は送信できない

    Args:
        uinfo: ConfDユーザー情報オブジェクト（応答送信時に使用）
        destination: pingの宛先（IPアドレスまたはホスト名）
        count: 送信するパケット数（デフォルト: 4）
    """
    global active_pings

    # UserInfoを文字列化してキーに利用（1アクション＝1キー）
    uinfo_key = str(uinfo)

    # pingコマンドの出力を保存するリスト
    output_lines = []

    try:
        # OSに応じてpingコマンドのオプションを設定
        cmd = build_ping_command(destination, count)

        log(f"Executing ping command: {' '.join(cmd)}")

        # 【プロセス起動】
        # subprocess.Popenでpingコマンドを子プロセスとして起動
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,      # 標準出力をパイプでキャプチャ
            stderr=subprocess.STDOUT,     # 標準エラーも標準出力にリダイレクト
            text=True                     # バイトではなくテキストで受け取る
        )

        # 【重要】プロセスをグローバル辞書に登録
        # cb_abort()がCtrl-C時にこのプロセスを取得して終了させるため
        active_pings[uinfo_key] = {
            'process': process,
            'aborted': False
        }

        # 【出力読み取り】
        # pingコマンドの出力を一行ずつ読み取り、リストに保存
        try:
            # 【重要】stdoutを読み切ってからwaitを呼ぶ
            # process.communicate()を使うと、デッドロックを防げる
            stdout_data, _ = process.communicate()

            # 出力を行ごとに分割してリストに追加
            for line in stdout_data.split('\n'):
                line_text = line.rstrip()   # 末尾の空白を削除
                if line_text:                # 空行はスキップ
                    output_lines.append(line_text)

        except Exception as e:
            log(f"Error during ping execution: {e}")
            output_lines.append(f"Error: {e}")
            # エラー時もプロセスが残っている可能性があるので終了させる
            try:
                process.kill()
                process.wait()
            except:
                pass

        # 【クリーンアップ】
        # pingが終了したので、グローバル辞書から削除
        # （cb_abortがもう呼ばれることはない）
        entry = active_pings.pop(uinfo_key, None)
        aborted = entry.get('aborted', False) if entry else False

        # 【結果判定】
        # returncode:
        #   0       : 正常終了
        #   正の値 : エラー終了（例: ホスト不明、ネットワークエラー）
        #   負の値 : シグナルで終了（例: -15 = SIGTERM, -9 = SIGKILL）
        success = process.returncode == 0
        output = '\n'.join(output_lines)

        if not success and process.returncode < 0:
            # 【中断ケース】
            # Ctrl-Cで中断された場合、returncodeは負の値になる
            # （process.terminate()がSIGTERM=15を送るので-15になる）
            log(f"Ping was interrupted (signal: {-process.returncode})")
            if aborted:
                # cb_abortが既に応答を返している
                log("Abort handled by cb_abort; skipping reply")
                return
            # 応答を返す前にエラーメッセージを設定
            result_message = "Ping interrupted by Ctrl-C"
            success = False
        elif success:
            result_message = output
        else:
            result_message = f"Ping to {destination} failed.\n{output}"

        log(f"Ping completed - success: {success}")

        # 【遅延応答の送信】
        # cb_action()で_confd.DELAYED_RESPONSEを返した場合、
        # ここでdp.action_reply_values()を呼んで結果を返す必要がある。
        if aborted:
            log("Skipping reply because cb_abort already responded")
            return

        try:
            # YANGモデルの出力パラメータに対応する値を設定
            # output { leaf result { ... } leaf success { ... } }
            result_values = [
                # resultパラメータ: pingの出力テキスト
                _confd.TagValue(
                    _confd.XmlTag(ns.ns.hash, ns.ns.ex_result),  # YANGのleaf名
                    _confd.Value(result_message, _confd.C_BUF)   # string型の値
                ),
                # successパラメータ: pingが成功したかどうか
                _confd.TagValue(
                    _confd.XmlTag(ns.ns.hash, ns.ns.ex_success), # YANGのleaf名
                    _confd.Value(success, _confd.C_BOOL)         # boolean型の値
                )
            ]
            # ConfDに応答を送信（これがCLIに表示される）
            dp.action_reply_values(uinfo, result_values)
            log("Reply sent successfully")
        except Exception as e:
            # クライアントが切断されている場合はエラーになるが、
            # それは正常な動作なので静かに終了
            log(f"Could not send reply (connection may be closed): {e}")

    except Exception as e:
        error_msg = f"Error executing ping: {str(e)}"
        log(f"ERROR: {error_msg}")

        # グローバル辞書から削除
        active_pings.pop(uinfo_key, None)

        # エラーを返す（遅延応答）
        try:
            send_action_reply(uinfo, error_msg, False)
        except Exception as e2:
            # 接続が閉じられている場合は静かに終了
            log(f"Could not send error reply (connection may be closed): {e2}")

# =============================================================================
# アクションコールバッククラス
# =============================================================================

class PingActionHandler:
    """
    pingアクションのハンドラークラス

    【役割】
    ConfD CLIで 'ping execute <destination>' コマンドが実行されたときに
    呼び出され、実際のping実行とレスポンスの返却を行います。

    【処理フロー】
    1. ConfD CLIでユーザーがpingコマンドを実行
    2. ConfDがこのハンドラーのcb_action()メソッドを呼び出し
    3. 入力パラメータ（destination, count）を取得
    4. システムpingコマンドを実行
    5. 結果を解析して出力パラメータ（result, success）を設定
    6. ConfDにレスポンスを返却
    7. CLIに結果が表示される
    """

    def cb_init(self, uinfo) -> int:
        """
        アクション初期化コールバック

        ConfDデーモンは "制御ソケット"(ctrl_sock) と
        "ワーカーソケット"(work_sock_global) の2本を使います。

        ここでは uinfo にワーカーソケットを関連付けることで、
        後続の cb_action / execute_ping からの応答
        (dp.action_reply_values など) が work_sock_global 経由で
        ConfD に返されるように設定します。

        Args:
            uinfo: ユーザー情報

        Returns:
            _confd.CONFD_OK
        """
        global work_sock_global
        log("Action initialized")
        # ユーザー情報にワーカーソケットを設定
        dp.action_set_fd(uinfo, work_sock_global)
        return _confd.CONFD_OK

    def cb_abort(self, uinfo) -> int:
        """
        アクション中止コールバック

        【呼び出されるタイミング】
        CLIでping実行中にユーザーがCtrl-Cを押したとき、
        ConfDがこのコールバックを呼び出します。

        【主な処理】
        1. active_pings辞書から実行中のプロセスを取得
        2. process.terminate()でSIGTERMシグナルを送信
        3. 0.1秒待ってまだ生きていたらprocess.kill()でSIGKILL
        4. execute_ping()スレッドのprocess.wait()が戻り、終了処理が走る

        【重要なConfDの仕様】
        Ctrl-Cが押されると、ConfDはクライアント接続を切断します。
        そのため、この後でdp.action_reply_values()を呼んでも
        結果をCLIに表示することはできません。
        CLIには "Aborted: by user" とだけ表示されます。

        Args:
            uinfo: ConfDユーザー情報オブジェクト

        Returns:
            _confd.CONFD_OK: 常に成功を返す
        """
        global active_pings

        log("Action aborted (Ctrl-C pressed)")

        uinfo_key = str(uinfo)

        if uinfo_key in active_pings:
            info = active_pings[uinfo_key]
            process = info['process']
            info['aborted'] = True  # execute_ping側に通知

            log(f"Terminating ping process (PID: {process.pid})")

            try:
                # 【ステップ 1】穏やかな終了を試みる（SIGTERM = 15）
                process.terminate()

                # 【ステップ 2】少し待って、まだ生きていたら強制終了
                time.sleep(0.1)
                if process.poll() is None:
                    process.kill()
                    process.wait()

                log("Ping process terminated")

            except Exception as e:
                log(f"Error terminating ping process: {e}")

            # 応答はここで返す（execute_ping側ではスキップされる）
            try:
                dp.action_delayed_reply_error(uinfo, "Action aborted by user")
                log("Abort reply sent from cb_abort")
            except Exception as e:
                log(f"Error sending abort reply: {e}")
        else:
            # プロセスが見つからない場合（既に終了しているなど）
            log("No active ping process found")

        return _confd.CONFD_OK

    def cb_finish(self, uinfo) -> int:
        """
        アクション終了コールバック（使用されない）

        Args:
            uinfo: ユーザー情報

        Returns:
            _confd.CONFD_OK
        """
        log("Action finished")
        return _confd.CONFD_OK

    def cb_action(self, uinfo, name, kp, params) -> int:
        """
        アクションコールバック

        Args:
            uinfo: ユーザー情報
            name: アクション名
            kp: キーパス
            params: 入力パラメータ

        Returns:
            _confd.DELAYED_RESPONSE: 遅延応答（別スレッドで結果を返す）
            _confd.CONFD_OK: 即座に成功
        """
        global work_sock_global

        try:
            log(f"Action callback invoked: {name}")

            # 【入力パラメータの解析】
            # YANGモデルの input { leaf destination ... leaf count ... }
            # から値を取得する
            destination = None
            count = 4  # YANGで定義したdefault値

            # paramsは_confd.TagValueオブジェクトのリスト
            # 各TagValueは YANGのleafに対応する
            for param in params:
                # destinationパラメータのチェック
                # ns.ns.ex_destinationはYANGから生成された定数
                if param.tag == ns.ns.ex_destination:
                    destination = str(param.v)  # _confd.Valueから文字列に変換
                    log(f"Input parameter - destination: {destination}")

                # countパラメータのチェック
                elif param.tag == ns.ns.ex_count:
                    count = int(param.v)  # _confd.Valueから整数に変換
                    log(f"Input parameter - count: {count}")

            # destinationは必須パラメータ
            if destination is None:
                error_msg = "Error: destination parameter is required"
                log(error_msg)
                # アクションの出力を設定
                send_action_reply(uinfo, error_msg, False)
                return _confd.CONFD_OK

            # 【別スレッドでping実行】
            # pingは数秒かかる処理なので、メインスレッドをブロックしないよう
            # 別スレッドで実行する
            log(f"Starting ping thread: destination={destination}, count={count}")
            ping_thread = threading.Thread(
                target=execute_ping,          # 実行する関数
                args=(uinfo, destination, count),  # 関数に渡す引数
                daemon=True                   # デーモンスレッド（メイン終了時に自動終了）
            )
            ping_thread.start()  # スレッド開始

            # 【遅延応答の宣言】
            # _confd.DELAYED_RESPONSEを返すことで、ConfDに以下を伝える:
            # - 「今すぐ結果を返さないが、後で返す」
            # - 別スレッドがdp.action_reply_values()を呼ぶまで待つ
            # - CLIはブロックし、結果が返るまで待つ
            log("Returning DELAYED_RESPONSE")
            return _confd.DELAYED_RESPONSE

        except Exception as e:
            error_msg = f"Error in action callback: {str(e)}"
            log(f"ERROR: {error_msg}")

            # エラーを即座に返す
            send_action_reply(uinfo, error_msg, False)
            return _confd.CONFD_OK

# =============================================================================
# デーモン管理関数
# =============================================================================

def daemonize() -> None:
    """プロセスをデーモン化する"""
    try:
        # 最初のfork
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError as e:
        log(f"First fork failed: {e}")
        sys.exit(1)

    # 環境をデタッチ
    os.chdir('/')
    os.setsid()
    os.umask(0)

    # 2回目のfork
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError as e:
        log(f"Second fork failed: {e}")
        sys.exit(1)

    # 標準入出力をリダイレクト
    sys.stdout.flush()
    sys.stderr.flush()

    with open(os.devnull, 'r') as f:
        os.dup2(f.fileno(), sys.stdin.fileno())

    with open(os.devnull, 'a+') as f:
        os.dup2(f.fileno(), sys.stdout.fileno())

    with open(os.devnull, 'a+') as f:
        os.dup2(f.fileno(), sys.stderr.fileno())

    # PIDファイルを書き込み
    pid = os.getpid()
    with open(PID_FILE, 'w') as f:
        f.write(f"{pid}\n")

    # 終了時にPIDファイルを削除
    atexit.register(lambda: PID_FILE.unlink(missing_ok=True))

def read_pid() -> Optional[int]:
    """PIDファイルからPIDを読み取る"""
    try:
        if PID_FILE.exists():
            with open(PID_FILE, 'r') as f:
                return int(f.read().strip())
    except:
        pass
    return None

def is_running(pid: int) -> bool:
    """指定されたPIDのプロセスが実行中かチェック"""
    try:
        os.kill(pid, 0)
        return True
    except OSError:
        return False

def stop_daemon() -> None:
    """デーモンを停止する"""
    pid = read_pid()

    if pid is None:
        print(f"{DAEMON_NAME} is not running (no PID file)")
        return

    if not is_running(pid):
        print(f"{DAEMON_NAME} is not running (stale PID file)")
        PID_FILE.unlink(missing_ok=True)
        return

    print(f"Stopping {DAEMON_NAME} (PID: {pid})...")

    try:
        os.kill(pid, signal.SIGTERM)

        # プロセスが終了するまで待機
        for i in range(50):
            if not is_running(pid):
                print(f"{DAEMON_NAME} stopped")
                PID_FILE.unlink(missing_ok=True)
                return
            time.sleep(0.1)

        # 強制終了
        print(f"{DAEMON_NAME} did not stop gracefully, forcing...")
        os.kill(pid, signal.SIGKILL)
        time.sleep(0.5)

        if not is_running(pid):
            print(f"{DAEMON_NAME} stopped")
            PID_FILE.unlink(missing_ok=True)
        else:
            print(f"Failed to stop {DAEMON_NAME}")

    except Exception as e:
        print(f"Error stopping daemon: {e}")

def check_status() -> None:
    """デーモンの状態を確認する"""
    pid = read_pid()

    if pid is None:
        print(f"{DAEMON_NAME} is not running (no PID file)")
        return

    if is_running(pid):
        print(f"{DAEMON_NAME} is running (PID: {pid})")
    else:
        print(f"{DAEMON_NAME} is not running (stale PID file)")
        PID_FILE.unlink(missing_ok=True)

# =============================================================================
# メイン処理
# =============================================================================

def run_daemon() -> None:
    """
    デーモンのメイン処理
    ConfDに接続してアクションハンドラーを登録し、イベントループを実行
    """
    global work_sock_global

    log(f"Starting {DAEMON_NAME}...")

    # デーモンコンテキストを初期化（最初に実行）
    log("Initializing daemon context...")
    daemon_ctx = dp.init_daemon(DAEMON_NAME)
    log("Daemon context initialized")

    # ConfDへのソケット接続
    # ctrl_sock: ConfDとの制御チャネル用ソケット
    #            (デーモン登録、再登録、制御イベントなど)
    ctrl_sock = socket.socket()

    # work_sock_global: アクション/DP呼び出し処理用のワーカーソケット
    #                   実際のアクションリクエストと応答のやり取りに使用
    work_sock_global = socket.socket()

    try:
        # ConfDに接続（daemon_ctxを第1引数に渡す）
        log(f"Connecting to ConfD at {CONFD_HOST}:{CONFD_PORT}...")
        dp.connect(daemon_ctx, ctrl_sock, dp.CONTROL_SOCKET, CONFD_HOST, CONFD_PORT, None)
        dp.connect(daemon_ctx, work_sock_global, dp.WORKER_SOCKET, CONFD_HOST, CONFD_PORT, None)
        log("Connected to ConfD")

        # アクションハンドラーを登録
        log(f"Registering action point: {ACTION_POINT_NAME}")
        action_handler = PingActionHandler()
        dp.register_action_cbs(daemon_ctx, ACTION_POINT_NAME, action_handler)

        # 登録完了を通知
        dp.register_done(daemon_ctx)
        log(f"{DAEMON_NAME} registration complete")

        # シグナルハンドラー設定
        stop_flag = {'stop': False}

        def signal_handler(signum, frame):
            log(f"Received signal {signum}, shutting down...")
            stop_flag['stop'] = True

        signal.signal(signal.SIGTERM, signal_handler)
        signal.signal(signal.SIGINT, signal_handler)

        # イベントループ
        log("Entering event loop...")
        sockets = [ctrl_sock, work_sock_global]

        while not stop_flag['stop']:
            # ソケットからの読み取りを待機
            readable, _, _ = select.select(sockets, [], [], 1.0)

            for sock in readable:
                try:
                    # データを読み取って処理（daemon_ctxを第1引数に渡す）
                    dp.fd_ready(daemon_ctx, sock)
                except _confd.error.Error as e:
                    # ConfDが接続を閉じた場合
                    if e.confd_errno == _confd.ERR_EOF:
                        log("ConfD closed connection, shutting down...")
                        stop_flag['stop'] = True
                        break
                    else:
                        log(f"Error processing socket data: {e}")
                        # その他のエラーの場合も停止
                        stop_flag['stop'] = True
                        break
                except Exception as e:
                    log(f"Error processing socket data: {e}")
                    # 予期しないエラーの場合も停止
                    stop_flag['stop'] = True
                    break

    except KeyboardInterrupt:
        log("Keyboard interrupt received")

    except Exception as e:
        log(f"Error in main loop: {e}")
        raise

    finally:
        log(f"Shutting down {DAEMON_NAME}")
        ctrl_sock.close()
        if work_sock_global:
            work_sock_global.close()

def main():
    """メイン関数"""
    parser = argparse.ArgumentParser(
        description=f'{DAEMON_NAME} - ConfD ping action handler'
    )

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--start', action='store_true',
                      help='Start daemon')
    group.add_argument('--stop', action='store_true',
                      help='Stop daemon')
    group.add_argument('--status', action='store_true',
                      help='Check daemon status')
    group.add_argument('--foreground', action='store_true',
                      help='Run in foreground (for testing)')

    args = parser.parse_args()

    if args.start:
        # 既に起動しているかチェック
        pid = read_pid()
        if pid and is_running(pid):
            print(f"{DAEMON_NAME} is already running (PID: {pid})")
            sys.exit(1)

        print(f"Starting {DAEMON_NAME}...")
        daemonize()
        run_daemon()

    elif args.stop:
        stop_daemon()

    elif args.status:
        check_status()

    elif args.foreground:
        print(f"Running {DAEMON_NAME} in foreground...")
        run_daemon()

if __name__ == '__main__':
    main()
