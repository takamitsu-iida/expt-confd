#!/usr/bin/env python3
"""
ConfD -> dnsmasq.conf 同期デーモン

- YANG: dnsmasq-dhcp.yang
- namespace python: dnsmasq_dhcp_ns.py (confdc --emit-python で生成)

ConfD の CDB を監視し、/dnsmasq/dhcp の設定から dnsmasq.conf を生成します。
初期実装では安全のため、デフォルト出力先を ./tmp/dnsmasq.conf とし、
必要に応じて環境変数 DNSMASQ_CONF_PATH で /etc/dnsmasq.conf などに切り替え可能です。
"""

import argparse
import atexit
import os
import signal
import socket
import sys
import threading
import time
from pathlib import Path
from typing import Optional

try:
    import _confd  # type: ignore
    import _confd.cdb as cdb  # type: ignore
except ImportError:
    print("Error: Could not import _confd.cdb module. Make sure ConfD is installed and PYTHONPATH is set correctly.")
    sys.exit(1)

try:
    import dnsmasq_dhcp_ns as ns  # generated by confdc
except ImportError:
    print("Error: Could not import dnsmasq_dhcp_ns. Run 'make all' to generate it from YANG.")
    sys.exit(1)

SCRIPT_BASE = Path(__file__).stem
SCRIPT_DIR = Path(__file__).resolve().parent.parent

TMP_DIR = SCRIPT_DIR / "tmp"
LOG_DIR = SCRIPT_DIR / "log"
CDB_DIR = SCRIPT_DIR / "confd-cdb"

PID_FILE = TMP_DIR / f"{SCRIPT_BASE}.pid"
LOG_FILE = LOG_DIR / f"{SCRIPT_BASE}.log"

CONFD_HOST = "127.0.0.1"
CONFD_PORT = 4565

# 出力先 dnsmasq.conf パス (デフォルトは ./tmp/dnsmasq.conf)
DEFAULT_DNSMASQ_CONF = SCRIPT_DIR / "tmp" / "dnsmasq.conf"
DNSMASQ_CONF_PATH = Path(os.environ.get("DNSMASQ_CONF_PATH", str(DEFAULT_DNSMASQ_CONF)))

WATCH_PATH = "/dnsmasq/dhcp"


class Subscriber:
    def __init__(self, prio: int = 100, path: str = WATCH_PATH) -> None:
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        self.path = path
        self.prio = prio

        cdb.connect(self.sock, cdb.SUBSCRIPTION_SOCKET, CONFD_HOST, _confd.CONFD_PORT, self.path)
        cdb.subscribe(self.sock, self.prio, ns.ns.hash, self.path)
        cdb.subscribe_done(self.sock)

        print(f"Subscribed to {self.path}")

    def loop(self) -> None:
        while True:
            cdb.read_subscription_socket(self.sock)
            self._write_dnsmasq_conf()
            cdb.sync_subscription_socket(self.sock, cdb.DONE_PRIORITY)

    def _write_dnsmasq_conf(self) -> None:
        rsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        cdb.connect(rsock, cdb.READ_SOCKET, CONFD_HOST, _confd.CONFD_PORT, "/")
        cdb.start_session(rsock, cdb.RUNNING)
        cdb.set_namespace(rsock, ns.ns.hash)

        tmp_path = DNSMASQ_CONF_PATH.with_suffix(".tmp")
        tmp_path.parent.mkdir(parents=True, exist_ok=True)

        with open(tmp_path, "w") as fp:
            fp.write("# Generated by dnsmasq_config_sync.py\n")
            fp.write("# Do not edit manually.\n\n")

            try:
                enabled = bool(cdb.get(rsock, f"{WATCH_PATH}/enabled"))
            except Exception:
                enabled = False

            if not enabled:
                fp.write("# DHCP disabled via ConfD\n")
            else:
                interface = _safe_get_str(rsock, f"{WATCH_PATH}/interface")
                if interface:
                    fp.write(f"interface={interface}\n")

                # address-pool -> dhcp-range
                try:
                    start_addr = _safe_get_str(rsock, f"{WATCH_PATH}/address-pool/start-address")
                    end_addr = _safe_get_str(rsock, f"{WATCH_PATH}/address-pool/end-address")
                    netmask = _safe_get_str(rsock, f"{WATCH_PATH}/address-pool/netmask")
                    gateway = _safe_get_str(rsock, f"{WATCH_PATH}/address-pool/gateway")
                    lease_time = _safe_get_str(rsock, f"{WATCH_PATH}/address-pool/lease-time")

                    if start_addr and end_addr and netmask:
                        parts = [start_addr, end_addr, netmask]
                        if gateway:
                            parts.append(gateway)
                        if lease_time:
                            parts.append(lease_time)
                        fp.write("dhcp-range=" + ",".join(parts) + "\n")
                except Exception as e:
                    print(f"Error building dhcp-range: {e}")

                # static-lease list -> dhcp-host
                try:
                    n_static = cdb.num_instances(rsock, f"{WATCH_PATH}/static-lease")
                    for i in range(n_static):
                        base = f"{WATCH_PATH}/static-lease[{i}]"
                        mac = _safe_get_str(rsock, base + "/mac")
                        ip = _safe_get_str(rsock, base + "/ip-address")
                        hostname = _safe_get_str(rsock, base + "/hostname")
                        if mac and ip:
                            fields = [mac, ip]
                            if hostname:
                                fields.append(hostname)
                            fp.write("dhcp-host=" + ",".join(fields) + "\n")
                except Exception as e:
                    print(f"Error reading static leases: {e}")

        cdb.end_session(rsock)
        rsock.close()

        os.replace(tmp_path, DNSMASQ_CONF_PATH)
        print(f"dnsmasq.conf written to {DNSMASQ_CONF_PATH}")


def _safe_get_str(sock: socket.socket, path: str) -> Optional[str]:
    try:
        v = cdb.get(sock, path)
        return str(v)
    except Exception:
        return None


def daemonize() -> None:
    TMP_DIR.mkdir(exist_ok=True)
    LOG_DIR.mkdir(exist_ok=True)

    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError as e:
        sys.stderr.write(f"fork #1 failed: {e}\n")
        sys.exit(1)

    os.chdir("/")
    os.setsid()
    os.umask(0)

    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError as e:
        sys.stderr.write(f"fork #2 failed: {e}\n")
        sys.exit(1)

    sys.stdout.flush()
    sys.stderr.flush()

    with open(str(LOG_FILE), "a") as log:
        os.dup2(log.fileno(), sys.stdout.fileno())
        os.dup2(log.fileno(), sys.stderr.fileno())

    with open(str(PID_FILE), "w") as f:
        f.write(str(os.getpid()))

    atexit.register(_cleanup_pid_file)


def _cleanup_pid_file() -> None:
    if PID_FILE.exists():
        PID_FILE.unlink()


def _get_pid() -> Optional[int]:
    try:
        return int(PID_FILE.read_text().strip())
    except Exception:
        return None


def _is_running(pid: Optional[int]) -> bool:
    if pid is None:
        return False
    try:
        os.kill(pid, 0)
        return True
    except OSError:
        return False


def start_daemon() -> None:
    pid = _get_pid()
    if _is_running(pid):
        print(f"dnsmasq_config_sync is already running (PID: {pid})")
        sys.exit(1)

    _cleanup_pid_file()

    print("Starting dnsmasq_config_sync daemon...")
    print(f"Log file: {LOG_FILE}")

    daemonize()
    run_loop()


def stop_daemon() -> None:
    pid = _get_pid()
    if not _is_running(pid):
        print("dnsmasq_config_sync is not running")
        _cleanup_pid_file()
        return

    print(f"Stopping dnsmasq_config_sync (PID: {pid})...")
    try:
        os.kill(pid, signal.SIGTERM)
        for _ in range(10):
            if not _is_running(pid):
                break
            time.sleep(0.5)
        if _is_running(pid):
            print("Forcing kill...")
            os.kill(pid, signal.SIGKILL)
    finally:
        _cleanup_pid_file()
        print("Stopped")


def status_daemon() -> None:
    pid = _get_pid()
    if _is_running(pid):
        print(f"dnsmasq_config_sync is running (PID: {pid})")
        print(f"Log file: {LOG_FILE}")
    else:
        print("dnsmasq_config_sync is not running")


def run_loop() -> None:
    CDB_DIR.mkdir(exist_ok=True)
    sub = Subscriber(10, WATCH_PATH)

    # 初回も設定を反映
    sub._write_dnsmasq_conf()

    stop_event = threading.Event()

    def handle_signal(signum, frame):
        print(f"Received signal {signum}, stopping...")
        stop_event.set()

    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)

    t = threading.Thread(target=sub.loop, daemon=True)
    t.start()

    stop_event.wait()


def main() -> None:
    parser = argparse.ArgumentParser(description="ConfD to dnsmasq.conf sync daemon")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--start", action="store_true", help="Daemonize and start")
    group.add_argument("--stop", action="store_true", help="Stop daemon")
    group.add_argument("--status", action="store_true", help="Show status")
    group.add_argument("--foreground", action="store_true", help="Run in foreground")
    args = parser.parse_args()

    if args.start:
        start_daemon()
    elif args.stop:
        stop_daemon()
    elif args.status:
        status_daemon()
    elif args.foreground:
        run_loop()
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
